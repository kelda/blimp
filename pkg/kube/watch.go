package kube

import (
	"context"
	"sync"

	log "github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/meta"
	"k8s.io/client-go/tools/cache"
)

// Watcher wraps an informer so that clients can easily subscribe to
// changes in the informer.
type Watcher struct {
	informer cache.SharedIndexInformer

	// Each subscriber is identified by an ID, which is generated by `idCtr`.
	// This ID is used for terminating watches.
	subscribers     map[int]subscriber
	subscribersLock sync.Mutex

	idCtr  int
	idLock sync.Mutex
}

// subscriber stores the channel that we should send notifications to when
// there's a change related to `notifyFor`.
type subscriber struct {
	notifyFor        Key
	notificationChan chan struct{}
}

// Key is used to filter what changes the subscriber is interested in.
type Key struct {
	Namespace, Name string
}

// ShouldNotify returns whether the given object is relevant to the given key.
// If a value isn't set in the key, then the field is ignored during the
// comparison. This is useful for watching multiple objects at once. For example,
// to watch for changes to all pods in a namespace, you can just leave the
// `Name` field empty.
func (key Key) ShouldNotify(namespace, name string) bool {
	if key.Namespace != "" && key.Namespace != namespace {
		return false
	}

	if key.Name != "" && key.Name != name {
		return false
	}

	return true
}

func NewWatcher(informer cache.SharedIndexInformer) *Watcher {
	watcher := &Watcher{
		informer:    informer,
		subscribers: map[int]subscriber{},
	}

	watcher.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    watcher.notifySubscribers,
		DeleteFunc: watcher.notifySubscribers,
		UpdateFunc: func(_, intf interface{}) {
			watcher.notifySubscribers(intf)
		},
	})

	return watcher
}

func (w *Watcher) Watch(ctx context.Context, notifyFor Key) chan struct{} {
	w.idLock.Lock()
	w.idCtr++
	id := w.idCtr
	w.idLock.Unlock()

	sub := subscriber{
		notifyFor:        notifyFor,
		notificationChan: make(chan struct{}, 1),
	}

	w.subscribersLock.Lock()
	w.subscribers[id] = sub
	w.subscribersLock.Unlock()

	go func() {
		<-ctx.Done()

		w.subscribersLock.Lock()
		delete(w.subscribers, id)
		w.subscribersLock.Unlock()
	}()

	return sub.notificationChan
}

func (w *Watcher) notifySubscribers(intf interface{}) {
	accessor, err := meta.Accessor(intf)
	if err != nil {
		log.WithField("obj", intf).
			Warn("Failed to get accessor")
		return
	}

	namespace := accessor.GetNamespace()
	name := accessor.GetName()

	// Send notifications to all subscribers.
	w.subscribersLock.Lock()
	defer w.subscribersLock.Unlock()
	for _, sub := range w.subscribers {
		if !sub.notifyFor.ShouldNotify(namespace, name) {
			continue
		}

		select {
		case sub.notificationChan <- struct{}{}:
		default:
		}
	}
}
